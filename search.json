[{"title":"BIOS/UEFI那套玩意","url":"/2024/07/BIOS-UEFI%E9%82%A3%E5%A5%97%E7%8E%A9%E6%84%8F/","content":"\n/ !  本文是对互联网文章的整理，便于自查，最佳阅读顺序可能不是自上而下。\n\nBoot\nboot这个称呼出自一句谚语\n\npull oneself up by one's bootstraps\n拽着鞋带把自己拉起来\n\n拽着鞋带把自己拉起来？这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！\n在早期必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做\"拉鞋带\"，久而久之就简称为boot了。\n磁盘\nOverview\n磁盘通常由多个盘片(platter) 组成，每个盘片有两个盘面，每个盘面都有一个读/写磁头(head) ，盘面从 0 开始自下向上依次编号，比如最下方的盘片具有 0 面和 1 面。\nhard drive geometry\n\n每个盘面都被划分为数目相等的磁道，并从 0 开始自外向内依次编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面(cylinder) 。磁盘的柱面数与一个盘面上的磁道数是相等的。\n下图为一个盘面，盘面上的同心圆为一条条磁道(track) ，一条磁道可以划分为若干扇区(sector) ，扇区是磁盘的最小组成单元，通常是 512 字节。簇(cluster) 是各种文件系统(如 FAT,NTFS)中数据的分配单元。在 Linux/Unix 中经常用块(Block) 来指代扇区或簇。\ndisk platter\n\n寻址\n\nCHS 寻址\nCylinder-head-sector(CHS) 通过(cylinder, head, sector)元组来定义块地址，该方案不适用于硬盘以外的设备。\nLBA 寻址\nLogical block addressing(LBA) 使用整数索引来定位块，如第一个块为LBA 0，第二个块为LBA 1，依此类推。从CHS到LBA的转换公式为 \\(A= (c \\times N_{heads}+h)\\times N_{sectors} + (s-1)\\)\n其中A是LBA地址，\\(N_{heads}\\)是磁盘上的磁头数量，\\(N_{sector}\\)是每个磁道的最大扇区数，\\((c,h,s)\\)是CHS地址。\n\nBIOS\nOverview\nBIOS(Basic Input/Output System)负责在通电启动阶段初始化硬件，并为操作系统提供运行时服务,是电脑启动加载的第一个程序。早年，BIOS通常储存于 ROM，现在的 BIOS 多储存于Flash，方便了 BIOS 的更新。\nBoot\nbios boot process\n\n\n硬件自检\n在电脑通电后，固化在ROM里的BIOS就会被加载到内存运行，BIOS 首先会进行硬件自检(Power-On Self-Test, POST),如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出 CPU、内存、硬盘等信息。\n启动顺序\n硬件自检完成后，BIOS 会把控制权转交给下一阶段的启动程序。 这时，BIOS 需要知道，\"下一阶段的启动程序\"具体存放在哪一个设备。也就是说，BIOS 需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做\"启动顺序\"(Boot Sequence).\nbios boot sequence\n\n\nBIOS 与 CMOS 的关系\nCMOS 是计算机上另一个重要的存储器。之所以提到它，是因为 BIOS 程序的设定值、硬件参数侦测值就保存在 CMOS 中。而且，在 BIOS 程式启动计算机时，需要载入 CMOS 中的设定值。UEFI 系统则多用NVRAM储存设定。\nBIOS 与 CMOS 的区别\n二者的区别是，BIOS 是储存在只读存储器(EEPROM或Flash)，而 CMOS 为随机存储器(RAM)；BIOS 中存储的是程序，而 CMOS 中存储的是普通信息。\n\n加载 MBR\n\nBIOS启动的时候，会按照CMOS设置里的顺序，挨个查看存储设备的前512字节是不是以0x55 0xAA(MBR 的 Magic number)结尾，如果不是，那就跳过找下一个设备；如果是的话，则表示这个磁盘可以启动，加载这512字节里的代码，执行之后，后面的事，几乎就跟BIOS没啥关系了。这最前面的512个字节，就叫做\"主引导记录\"(Master boot record，MBR) ，MBR的主要作用就是告诉计算机到硬盘的哪个位置寻找操作系统。\n\n硬盘启动\n\n这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成两种情况。\n\n情况A：卷引导记录\n上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做VBR。\n\"卷引导记录\"的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。\n情况B：启动管理器\n在这种情况下，计算机读取\"主引导记录\"前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的\"启动管理器\" (boot loader) ，由用户选择启动哪一个操作系统。\n例如Windows的bootmgr和Linux的Grub。\n\nUEFI\nUEFI(Unified Extensible Firmware Interface) ，即“统一的可扩展固件接口”，是一种详细描述全新类型接口的标准，是适用于电脑的标准固件接口，旨在代替BIOS。此标准由intel公司带头组织UEFI联盟中的140多个技术公司共同创建。\n它不仅仅是BIOS替换。UEFI本质上是一个运行在PC固件之上的微型操作系统，它可以做的比BIOS多得多。它可以存储在主板的闪存中，也可以在启动时从硬盘或网络共享加载。一般的UEFI系统仅能识别FAT32，不同于BIOS只能识别固定位置的磁盘引导块。这意味着只要将引导程序放到FAT32分区里，UEFI系统就能通过分区表的指引找到这个保存着引导程序的FAT32分区。UEFI系统是由模块化的C语言程序写出来的，所以通过添加或修改程序模块就能获得更多的功能。例如支持更多的文件系统，图形界面，甚至能使用浏览器浏览网页。\nMBR\n主引导记录(Master Boot Record, MBR)，又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为(柱面，磁头，扇区)＝(0，0，1)。\n\nMBR具有多个不同版本，可能具有不同的分区表数量，如Advanced Active Partitions (AAP) 扩展为 5 个, (AST and NEC MS-DOS 3.x) 扩展为 8 个等。此处说明的结构为classic generic MBR.\n\nDisk Layout - MBR\n\nOverview\nMBR位于磁盘的第一个逻辑扇区，即LBA0的位置。MBR只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。\n\n　　(1) 第1-446字节：调用操作系统的机器码。\n　　(2) 第447-510字节：分区表(Partition table)。\n　　(3) 第511-512字节：主引导记录签名(0x55和0xAA)。\n\nMaster Boot Code\nMBC位于MBR开头的446字节。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序(如GNU GRUB)。它不依赖任何操作系统，且启动代码也可修改以实现多系统引导。\n\n在深入讨论主引导扇区内部结构的时候，有时也将其MBC特指为MBR\n\nDPT\n考虑到每个区可以安装不同的操作系统，MBR因此必须知道将控制权转交给哪个区，该任务由硬盘分区表(Disk Partition Table)完成，DPT占据主引导扇区的 64 个字节(偏移0x01BE--偏移0x01FD)，可以对四个分区的信息进行描述，其中每个分区的信息占据 16B。进一步的信息参见DPT。\nMBR分区表使用4B来记录分区逻辑地址和扇区总数，故单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是使用GPT。\n\n2TB 怎么来的?\n16字节的分区表中，用于存储分区长度的只有8B，则分区地址最大值为 \\(2^{32}-1\\) ，可以索引4,294,967,295个扇区。每个扇区为512B，则最大空间为\n\\[ 512 \\times 4,294,967,295 = 2,199,023,255,040\\] Bytes\n约为2TB (2,000,000,000,000 Bytes)\n\nBoot signature\n55,AA(0x01FE－0x01FF)为最后两个字节，是检验主引导记录是否有效的标志。\nPrimary Partition\n\nVBR(Volume boot record), 或PBR(Partition boot record)，对应卷引导记录，在分区设备(如硬盘)上，它是设备上单个分区的第一个扇区 。VBR中通常包括操作系统的机器代码，VBR中的代码可由MBR或bootloader间接调用。卷引导记录的主要作用是，告诉计算机操作系统在这个分区里的位置。上图的蓝色部分。\nFile System：操作系统对磁盘的所有操作都需要经过文件系统，删除文件指的是在文件系统里删除文件的索引条目，创建文件就是在在文件系统里添加索引条目并将具体数据写入磁盘。常见的文件系统格式有：FAT、ext4、NTFS。文件系统位置一般在PBR之后。上图粉色部分。\n\nExtended Partition\nMBR最多支持创建 4 个主分区。不过，这个限制可以通过创建扩展分区(Extended Partition) 来绕过(3 个主分区 + 1 个扩展分区)。在扩展分区中，又可以包含多个逻辑分区(Logical Partition) ，但是逻辑分区不能用作引导卷，这也是它的一个重要限制。\n计算机先读取扩展分区的第一个扇区，叫做\"扩展引导记录\"(Extended boot record, EBR) 。它里面也包含一张64字节的分区表，但是最多只有两项(也就是两个逻辑分区)。\n计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止(即只有一个分区项)。因此，扩展分区可以包含无数个逻辑分区。\nGPT\nOverview\nGPT(Globally Unique Identifier Partition Table) ，即全局唯一标识码分区表，简称GPT或GUID分区表，它是UEFI规范的一部分。由于MBR和BIOS的局限性，GPT应运而生。GPT由GPT头和GPT主体，GPT备份组成。起始于磁盘LBA1的位置，相对的LBA0仍然为MBR，但是这个MBR是被保护的，没有引导代码，仅仅有一个被标识为未知的分区，当支持GPT分区表的操作系统检索到这个MBR后就会自动忽略并跳到LBA1读取GPT分区表。\ngpt structure\n\nProtective MBR (LBA0)\nPMBR(Protective MBR)存在的意义是当不支持GPT的分区的程序（例如MS-DOS和老版本的fdisk）在读取使用GPT分区的硬盘时，会看到一个被未知类型分区类型(0xEE)占用了全部磁盘空间的磁盘，此时会拒绝写入，以防止意外修改GPT分区表。而支持GPT的系统在检测PMBR后会直接跳到GPT表头读取分区表。和MBR类似，分区表中存储了某个分区的起始和结束位置及其文件系统属性信息。\nPartition table header (LBA 1)\n分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，分区表头位置（总是LBA1）和大小，也包含了备份分区表头和分区表的位置和大小信息（LBA-1~LBA-34）。同时还储存着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错，如果出错，可以使用软件从硬盘最后的备份GPT中恢复整个分区表，如果备份GPT也校验错误，硬盘将不可使用。\nPartition entries (LBA 2–33)he\nGPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是&#123;C12A7328-F81F-11D2-BA4B-00A0C93EC93B&#125;。接下来的16字节是该分区唯一的GUID（这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型）。\n\n\n\n起始字节\n长度\n内容\n\n\n\n\n0\n16字节\n分区类型GUID\n\n\n16\n16字节\n分区GUID\n\n\n32\n8字节\n起始LBA（小端序）\n\n\n40\n8字节\n末尾LBA\n\n\n48\n8字节\n属性标签（如：60表示\"只读\"）\n\n\n56\n72字节\n分区名（可以包括36个UTF-16（小端序）字符）\n\n\n\nPartition backup (LBA-33 ~ LBA-1)\n为了减少分区表损坏的风险，GPT在硬盘最后(LBA-33 ~ LBA-1)保存了一份分区表的副本。\nDPT\n硬盘分区表(Disk Partition Table)占据MBR的 64 个字节，实现了硬盘分区，硬盘分区有很多好处。DPT负责告诉操作系统，磁盘的分区有几个，从哪里开始到哪里结束。当将一个磁盘插入已经含有操作系统的机器上时，操作系统会检索这个磁盘的分区表，并正确认识它的分区结构。一个磁盘是先有分区表，后有分区，然后才有文件系统，有了文件系统才能被操作系统读写删。磁盘分区表格式目前主要有两种，分别是MBR分区表和GPT分区表。\nDPT占据 64 个字节，可以对四个分区的信息进行描述，其中每个分区的信息占据 16 个字节。每个主分区的16个字节，由6个部分组成：\n\n　　(1) 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。\n　　(2) 第2-4个字节：主分区第一个扇区的物理位置(柱面、磁头、扇区号等等)。\n　　(3) 第5个字节：主分区类型。\n　　(4) 第6-8个字节：主分区最后一个扇区的物理位置。\n　　(5) 第9-12字节：该主分区第一个扇区的逻辑地址。\n　　(6) 第13-16字节：主分区的扇区总数。\n\nGPT vs MBR\n上文提到，DPT有GPT和MBR两种分区表：\nMBR &amp; GPT structure\n\nBoot Loader\nGrub\nGRUB(Grand Unified Boot loader)是硬盘中的软件，引导器(loader)的一种。目前主流版本是 GRUB2。\nGRUB用于从多操作系统的计算机中选择一个系统来启动，或从系统分区中选择特殊的内核配置。\n结构\nGrub启动代码(boot.img)直接安装在MBR中，然后执行GRUB内核镜像(core.img)，最后从/boot/grub中读取配置和其他功能代码。\ngrub2 structure\n\n\n在MBR分区表中，boot.img和core.img都在MBR中。MBR虽然只占用一个扇区(512Byte)，但是其所在的磁道是空闲的，不会用于分区，可以放下core.img。\n\n\nSome MBR code loads additional code for a boot manager from the first track of the disk, which it assumes to be \"free\" space that is not allocated to any disk partition, and executes it. -- MBR Wikipedia\n\n\n在GPT分区表中，MBR为protected MBR(为兼容MBR，在硬盘起始位置保留的空间)，后面并没有空间放core.img，需要建一个专门的分区来放，称为BIOS boot partition，该分区的文件类型为unformatted，flag为BOIS_grub，该flag用于标识core.img所要安装到的分区。若使用UEFI引导，GRUB读取的是ESP分区中的数据，不需要flag为BIOS_grub的分区。\n\nREFER\n\n聊聊 BIOS、UEFI、MBR、GPT、GRUB……\nLinux Boot Process Explained Step by Step in Detail\n计算机是如何启动的？\nWhat is the difference in \"Boot with BIOS\" and \"Boot with UEFI\"\nWikipedia\n\n","categories":["OS"],"tags":["linux"]}]